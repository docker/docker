import json
import time
import subprocess
import os
import pytest
import requests
from docker import Client as DockerClient
import splunklib.client as Client
import splunklib.results as Results

requests.packages.urllib3.disable_warnings()

def run_search(splunk, query):
    job = splunk.jobs.create(query)
    while not job.is_done():
        pass
    all_results = Results.ResultsReader(job.results())
    job.cancel()
    return list(all_results)


class TestSplunkLoggingDriver(object):

    @classmethod
    def setup_class(cls):
        '''
        Starting the Splunk container and make sure it's up and running.
        '''
        splunk = subprocess.Popen('docker run --name splunk_currga -p 8089:8089 -p 8088:8088 -p 8000:8000 -d --env SPLUNK_START_ARGS="--accept-license" splunk:new', shell=True)
        splunk.wait()
        # Try to ping Splunk to make sure it is running (25 attempts max).
        for i in range(25):
            try:
                r = requests.get("https://localhost:8089/services/server/info", verify=False)
                if r.status_code == 200:
                    break
            except:
                time.sleep(2)

    @classmethod
    def teardown_class(cls):
        '''
        Killing the docker container splunk_currga
        '''
        kill = subprocess.Popen('docker stop splunk_currga; docker rm splunk_currga', shell=True)
        kill.wait()

    def test_docker_up(self):
        '''
        Check if the container created in the setup_class is up and running.
        '''
        if "DOCKER_HOST" in os.environ.keys():
            d = DockerClient(base_url=os.environ["DOCKER_HOST"])
        else:
            d = DockerClient()
        all_conts = d.containers()
        # There should only be 1 container running (Splunk)
        assert len(all_conts) == 1
        # Check container image name
        assert "splunk:new" in all_conts[0]["Image"]

    def test_event_count(self):
        '''
        Run a hello-world image using the Splunk logging driver. The output from the hello-world image is sent to the STDOUT,
        which should be sent to Splunk via HEC. 
        '''
        # Run hello-world container with Splunk logging driver enabled
        hello_world = subprocess.check_output("docker run -d --log-driver=splunk --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true hello-world" % os.uname()[1], shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(10)
        # Remove container
        rm = subprocess.Popen("docker rm %s" % hello_world, shell=True)
        rm.wait()
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = 'search earliest=-90s | spath tag | search tag="*%s*"' % hello_world[0:12]
        results = run_search(splunk, query)
        # Hello world image will print 21 lines to STDOUT, so 21 events should be captured
        assert len(results) == 21
        # "Host" field should be consistent with docker container ID
        assert results[0]["host"] == os.uname()[1]

    def test_logged_content(self):
        '''
        Check the content of the events generated by the hello-world image. 
        '''
        # Run hello-world container with Splunk logging driver enabled
        hello_world = subprocess.check_output("docker run -d --log-driver=splunk --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true hello-world" % os.uname()[1], shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(10)
        # Remove container
        rm = subprocess.Popen("docker rm %s" % hello_world, shell=True)
        rm.wait()
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = 'search earliest=-90s | spath tag | search tag="*%s*" | stats values(line) as msg by _time | mvexpand msg' % hello_world[0:12]
        results = run_search(splunk, query)
        msg = ""
        for res in results:
            msg += res["msg"] + "\n"
        # Check that the message lines print correctly
        assert "Hello from Docker!" in msg
        assert "This message shows that your installation appears to be working correctly." in msg
        assert "1. The Docker client contacted the Docker daemon." in msg
        assert '2. The Docker daemon pulled the "hello-world" image from the Docker Hub.' in msg
        assert "3. The Docker daemon created a new container from that image which runs the" in msg
        assert "executable that produces the output you are currently reading." in msg
        assert "$ docker run -it ubuntu bash" in msg
        assert "https://hub.docker.com" in msg

    def test_single_event(self):
        '''
        Run a nginx image using the Splunk logging driver. Then send a curl request, which should send exactly one event.
        '''
        # Run nginx container with Splunk logging driver enabled
        nginx = subprocess.check_output("docker run --publish 80:80 --log-driver=splunk --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d nginx" % os.uname()[1], shell=True)
        # Send curl request to localhost server
        ping_nginx_cmd = subprocess.check_output("curl http://localhost:80", shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(10)
        # Remove container
        rm = subprocess.Popen("docker stop %s; docker rm %s" % (nginx, nginx), shell=True)
        rm.wait()
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = "search earliest=-90s | spath tag | search tag=%s" % nginx[0:12]
        results = run_search(splunk, query)
        # Only 1 event should be logged
        assert len(results) == 1
        # "Host" field should be consistent with docker container ID
        assert results[0]["host"] in os.uname()[1]

    def test_tags(self):
        '''
        Run a nginx image using the Splunk logging driver with tags enabled. Then send a curl request, and check the logged content.
        '''
        # Run nginx container named 'jerry_seinfeld' with Splunk logging driver enabled and tags modified
        nginx = subprocess.check_output('docker run --name jerry_seinfeld --publish 80:80 --log-driver=splunk --log-opt tag="{{.ImageName}}/{{.Name}}/{{.ID}}" --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d nginx' % os.uname()[1], shell=True)
        # Send curl request to localhost server
        ping_nginx_cmd = subprocess.check_output("curl http://localhost:80/kramer", shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(10)
        # Remove container
        rm = subprocess.Popen("docker stop %s; docker rm %s" % (nginx, nginx), shell=True)
        rm.wait()
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = 'search earliest=-90s | spath tag | search tag="nginx/%s/%s"' % ('jerry_seinfeld', nginx[0:12])
        results = run_search(splunk, query)
        # The nginx image should have 2 events, one for stdout and one for stderr
        assert len(results) == 2
        # "Host" field should be consistent with docker container ID
        assert results[0]["host"] in os.uname()[1]
        # The curl request sent was meant to fail, so we should see 404 and error messages
        if "stdout" in results[0]["source"]:
            stdout, stderr = results[0], results[1]
        else:
            stdout, stderr = results[1], results[0]
        assert "stderr" in stderr["source"]
        assert "[error]" in json.loads(stderr["_raw"])["line"]
        assert " 404 " in json.loads(stdout["_raw"])["line"]
        assert "GET /kramer" in json.loads(stdout["_raw"])["line"]

    def test_splunk_source(self):
        '''
        Run a nginx image using the Splunk logging driver with source overridden. Then send a curl request, and check the logged content.
        '''
        # Run nginx container with Splunk logging driver enabled and source overridden
        nginx = subprocess.check_output('docker run --publish 80:80 --log-driver=splunk --log-opt splunk-source=testSource --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d nginx' % os.uname()[1], shell=True)
        # Send curl request to localhost server
        ping_nginx_cmd = subprocess.check_output("curl http://localhost:80?overridingsource", shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(10)
        # Remove container
        rm = subprocess.Popen("docker stop %s; docker rm %s" % (nginx, nginx), shell=True)
        rm.wait()
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = "search earliest=-90s | spath tag | search tag=%s" % nginx[0:12]
        results = run_search(splunk, query)
        # Only 1 event should be logged
        assert len(results) == 1
        # Check if source is changed
        assert "testSource" in results[0]["source"]
        # Check line message content
        line = json.loads(results[0]["_raw"])["line"]
        assert " 200 " in line
        assert "/?overridingsource" in line

    def test_splunk_sourcetype(self):
        '''
        Run a nginx image using the Splunk logging driver with sourcetype overridden. Then send a curl request, and check the logged content.
        '''
        # Run nginx container with Splunk logging driver enabled and sourcetype overridden
        nginx = subprocess.check_output('docker run --publish 80:80 --log-driver=splunk --log-opt splunk-sourcetype=testSourcetype --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d nginx' % os.uname()[1], shell=True)
        # Send curl request to localhost server
        ping_nginx_cmd = subprocess.check_output("curl http://localhost:80?overridingsourcetype", shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(10)
        # Remove container
        rm = subprocess.Popen("docker stop %s; docker rm %s" % (nginx, nginx), shell=True)
        rm.wait()
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = "search earliest=-90s | spath tag | search tag=%s" % nginx[0:12]
        results = run_search(splunk, query)
        # Only 1 event should be logged
        assert len(results) == 1
        # "Host" field should be consistent with docker container ID
        assert results[0]["host"] in os.uname()[1]
        # Check if sourcetype is changed
        assert "testSourcetype" in results[0]["sourcetype"]
        # Check line message content
        line = json.loads(results[0]["_raw"])["line"]
        assert " 200 " in line
        assert "/?overridingsourcetype" in line

    def test_splunk_index(self):
        '''
        Run a nginx image using the Splunk logging driver with index specified. Then send a curl request, and check the logged content.
        NOTE: For this to work properly, the new index must be selected in "Allowed Indexes" in HEC. 
              In conf file terms, see $SPLUNK_HOME/etc/apps/splunk_httpinput/local/inputs.conf here:
              [http://<name>]
              disabled = 0
              index = main
              indexes = main,dockertest      <--- additional indexes specified here
              token = <token>
        '''
        # Run nginx container with Splunk logging driver enabled and index overridden
        nginx = subprocess.check_output('docker run --publish 80:80 --log-driver=splunk --log-opt splunk-index=dockertest --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d nginx' % os.uname()[1], shell=True)
        # Send curl request to localhost server
        ping_nginx_cmd = subprocess.check_output("curl http://localhost:80?overridingindex", shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(10)
        # Remove container
        rm = subprocess.Popen("docker stop %s; docker rm %s" % (nginx, nginx), shell=True)
        rm.wait()
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = "search index=dockertest earliest=-90s | spath tag | search tag=%s" % nginx[0:12]
        results = run_search(splunk, query)
        # Only 1 event should be logged
        assert len(results) == 1
        # "Host" field should be consistent with docker container ID
        assert results[0]["host"] in os.uname()[1]
        # Check if index is changed
        assert results[0]["index"] == "dockertest"
        # Check line message content
        line = json.loads(results[0]["_raw"])["line"]
        assert " 200 " in line
        assert "/?overridingindex" in line

    def test_labels(self):
        '''
        Run a nginx image using the Splunk logging driver with labels specified. Then send a curl request, and check the logged content.
        '''
        # Run nginx container with Splunk logging driver enabled and additional labels passed through
        nginx = subprocess.check_output('docker run --label name=test_labels --label location=home --publish 80:80 --log-driver=splunk --log-opt labels=name,location --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d nginx' % os.uname()[1], shell=True)
        # Send curl request to localhost server
        ping_nginx_cmd = subprocess.check_output("curl http://localhost:80?labels", shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(10)
        # Remove container
        rm = subprocess.Popen("docker stop %s; docker rm %s" % (nginx, nginx), shell=True)
        rm.wait()
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = "search earliest=-90s | spath tag | search tag=%s" % nginx[0:12]
        results = run_search(splunk, query)
        # Only 1 event should be logged
        assert len(results) == 1
        # "Host" field should be consistent with docker container ID
        assert results[0]["host"] in os.uname()[1]
        # Check attrs dictionary for labels/envs
        attrs = json.loads(results[0]["_raw"])["attrs"]
        assert attrs["name"] == "test_labels"
        assert attrs["location"] == "home"
        # Check line message content
        line = json.loads(results[0]["_raw"])["line"]
        assert " 200 " in line
        assert "/?labels" in line

    def test_envs(self):
        '''
        Run a nginx image using the Splunk logging driver with env variables specified. Then send a curl request, and check the logged content.
        '''
        # Run nginx container with Splunk logging driver enabled and additional env variables passed through
        nginx = subprocess.check_output('docker run --env "TESTNAME=test_envs" --publish 80:80 --log-driver=splunk --log-opt env=TESTNAME --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d nginx' % os.uname()[1], shell=True)
        # Send curl request to localhost server
        ping_nginx_cmd = subprocess.check_output("curl http://localhost:80?envs", shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(10)
        # Remove container
        rm = subprocess.Popen("docker stop %s; docker rm %s" % (nginx, nginx), shell=True)
        rm.wait()
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = "search earliest=-90s | spath tag | search tag=%s" % nginx[0:12]
        results = run_search(splunk, query)
        # Only 1 event should be logged
        assert len(results) == 1
        # "Host" field should be consistent with docker container ID
        assert results[0]["host"] in os.uname()[1]
        # Check attrs dictionary for labels/envs
        assert json.loads(results[0]["_raw"])["attrs"]["TESTNAME"] == "test_envs"
        # Check line message content
        line = json.loads(results[0]["_raw"])["line"]
        assert " 200 " in line
        assert "/?envs" in line

    def test_labels_and_envs(self):
        '''
        Run a nginx image using the Splunk logging driver with labels and env variables specified. Then send a curl request, and check the logged content.
        By design, if env variables conflict with label names, env variables take precedence.
        '''
        # Run nginx container with Splunk logging driver enabled and conflicting labels + env variables passed through
        nginx = subprocess.check_output('docker run --env "test=foo" --env "newenv=1" --label test=bar --label newlabel=two --publish 80:80 --log-driver=splunk --log-opt labels=test,newlabel --log-opt env=test,newenv --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d nginx' % os.uname()[1], shell=True)
        # Send curl request to localhost server
        ping_nginx_cmd = subprocess.check_output("curl http://localhost:80?labelsandenvs", shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(10)
        # Remove container
        rm = subprocess.Popen("docker stop %s; docker rm %s" % (nginx, nginx), shell=True)
        rm.wait()
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = "search earliest=-90s | spath tag | search tag=%s" % nginx[0:12]
        results = run_search(splunk, query)
        # Only 1 event should be logged
        assert len(results) == 1
        # "Host" field should be consistent with docker container ID
        assert results[0]["host"] in os.uname()[1]
        # Check attrs dictionary for labels/envs
        attrs = json.loads(results[0]["_raw"])["attrs"]
        assert attrs["test"] == "foo"
        assert attrs["newenv"] == "1"
        assert attrs["newlabel"] == "two"
        # Check line message content
        line = json.loads(results[0]["_raw"])["line"]
        assert " 200 " in line
        assert "/?labelsandenvs" in line

    def test_verify_false_connection(self):
        '''
        Run a hello-world image using the Splunk logging driver with splunk-verify-connection as set to "false".
        The splunk-url is purposely set incorrectly to "https://newman:8088" to make see if the logging 
        driver will not error out.
        '''
        try:
            # Run hello-world container with Splunk logging driver enabled and splunk-verifyconnection==false
            run_hw = subprocess.check_output("docker run --log-driver=splunk --log-opt splunk-verify-connection=false --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://newman:8088 --log-opt splunk-insecureskipverify=true -d hello-world", shell=True)
        except subprocess.CalledProcessError:
            assert False
        assert True

    def test_verify_true_connection(self):
        '''
        Run a hello-world image using the Splunk logging driver with splunk-verify-connection as set to "true".
        The splunk-url is purposely set incorrectly to "https://newman:8088" to make see if the logging 
        driver will error out.
        '''
        try:
            # Run hello-world container with Splunk logging driver enabled and splunk-verifyconnection==true
            run_hw = subprocess.check_output("docker run --log-driver=splunk --log-opt splunk-verify-connection=true --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://newman:8088 --log-opt splunk-insecureskipverify=true -d hello-world", stderr=subprocess.STDOUT, shell=True)
        except subprocess.CalledProcessError, cpe:
            assert "Failed to initialize logging driver" in cpe.output

    def test_format_inline(self):
        '''
        Run a tutum/curl image (Ubuntu w/ curl installed) with the Splunk logging driver enabled. Then send a curl
        request to curl https://api.twitter.com/1.1/search/tweets.json?q=%%40SeinfeldToday to get a JSON response, 
        but log it as format=inline.
        '''
        # Run tutum-curl container with Splunk logging driver enabled and splunk-format=inline
        run_curl = subprocess.check_output('docker run --log-driver=splunk --log-opt splunk-format=inline --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d tutum/curl curl -s curl https://api.twitter.com/1.1/search/tweets.json?q=%%40SeinfeldToday' % (os.uname()[1]), shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(10)
        print run_curl
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = 'search "*%s*"' % run_curl[0:12]
        results = run_search(splunk, query)
        # Check response
        assert len(results) == 1
        # Check line message
        line = json.loads(results[0]["_raw"])["line"]
        assert type(line) == unicode
        assert line == "{\"errors\":[{\"code\":215,\"message\":\"Bad Authentication data.\"}]}"

    def test_format_json(self):
        '''
        Run a tutum/curl image (Ubuntu w/ curl installed) with the Splunk logging driver enabled. Then send a curl
        request to curl https://api.twitter.com/1.1/search/tweets.json?q=%%40SeinfeldToday to get a JSON response, 
        but log it as format=json.
        '''
        # Run tutum-curl container with Splunk logging driver enabled and splunk-format=json
        run_curl = subprocess.check_output('docker run --log-driver=splunk --log-opt splunk-format=json --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d tutum/curl curl -s curl https://api.twitter.com/1.1/search/tweets.json?q=%%40SeinfeldToday' % (os.uname()[1]), shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(25)
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = 'search "*%s*"' % run_curl[0:12]
        results = run_search(splunk, query)
        # Check response
        assert len(results) == 1
        # Check line message
        line = json.loads(results[0]["_raw"])["line"]
        assert type(line) == dict
        assert line == {"errors":[{"code":215,"message":"Bad Authentication data."}]}

    def test_format_raw(self):
        '''
        Run a tutum/curl image (Ubuntu w/ curl installed) with the Splunk logging driver enabled. Then send a curl
        request to curl https://api.twitter.com/1.1/search/tweets.json?q=%%40SeinfeldToday to get a JSON response, 
        but log it as format=raw.
        '''
        # Run tutum-curl container with Splunk logging driver enabled and splunk-format=raw
        run_curl = subprocess.check_output('docker run --log-driver=splunk --log-opt splunk-format=raw --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d tutum/curl curl -s curl https://api.twitter.com/1.1/search/tweets.json?q=%%40SeinfeldToday' % (os.uname()[1]), shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(25)
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = 'search "*%s*"' % run_curl[0:12]
        results = run_search(splunk, query)
        # Check response
        assert len(results) == 1
        # Check line message
        line = results[0]["_raw"]
        assert type(line) == str
        assert line.startswith(run_curl[0:12])
        assert "{\"errors\":[{\"code\":215,\"message\":\"Bad Authentication data.\"}]}" in line

    def test_raw_labels_and_envs(self):
        '''
        Run a tutum/curl image (Ubuntu w/ curl installed) with the Splunk logging driver enabled. Then send a curl
        request to curl https://api.twitter.com/1.1/search/tweets.json?q=%%40SeinfeldToday to get a JSON response, 
        but log it as format=raw.
        '''
        # Run tutum-curl container with Splunk logging driver enabled and splunk-format=raw
        run_curl = subprocess.check_output('docker run --name elaine --env "test=foo" --env "newenv=1" --label test=bar --label newlabel=two --log-driver=splunk --log-opt tag="{{.Name}}@{{.ID}}" --log-opt labels=test,newlabel --log-opt env=test,newenv --log-opt splunk-format=raw --log-opt splunk-token=SPLUNK-LOGGER-DOCKER --log-opt splunk-url=https://%s:8088 --log-opt splunk-insecureskipverify=true -d tutum/curl curl -s curl https://api.twitter.com/1.1/search/tweets.json?q=%%40SeinfeldToday' % (os.uname()[1]), shell=True)
        # Sleep to allow Splunk to index the data
        time.sleep(25)
        # Check results in Splunk
        splunk = Client.connect(host="localhost", port=8089, username="admin", password="changeme")
        query = 'search "*%s*"' % run_curl[0:12]
        results = run_search(splunk, query)
        # Check response
        assert len(results) == 1
        # Check line message
        line = results[0]["_raw"]
        assert type(line) == str
        assert line.startswith("elaine@"+run_curl[0:12])
        assert "test=foo" in line
        assert "newenv=1" in line
        assert "newlabel=two" in line
        assert line.endswith("{\"errors\":[{\"code\":215,\"message\":\"Bad Authentication data.\"}]}")