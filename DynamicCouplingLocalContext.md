### TLDR
Constructs a virtual build context derived from the uploaded one, similar to creating a directory structure comprised entirely of symbolic links, that exactly specifies what's needed or exposed to a FROM statement and its related Dockerfile commands. This supports writing a series of ADD/COPY commands according to a given interface (context local to the FROM) so they can be decoupled from the uploaded build context.  Decoupling encourages reuse, for example, encapsulating ADD/COPY commands within ONBUILD triggers, as their source path/file references can be redirected to the appropriate ones for any uploaded build context without having to rewrite them.
###TOC
<a href="#Description">Description</a><br>
<a href="#Syntax">Syntax</a><br>
<a href="#Semantics">Semantics</a><br>
<a href="#Benefits">Benefits</a><br>
<a href="#Example">Example</a><br>
### Description  <a name="Description">

Dockerfile commands pathologically couple to the structure of the build context provided by "docker build" and since the structure of a build context varies markedly from one "docker build" image request to the next, certain Dockerfile binding commands, like ADD, must be "repeated": manually encoded to reflect the unique structure of each image's build context.  Moreover, this harmful coupling diminishes the utility of both present and future language elements that would benefit from the ability to statically bind to a path/file name (that acts like a variable name) when writing Dockerfile commands, that when executed, are then dynamically resolved and (dynamically) coupled to the actual path/file instance (variable value).  For example, the ADD commands of an image's [ONBUILD triggers](https://docs.docker.com/reference/builder/#onbuild) must either specify path/file names which also requires these names be mirrored by all build contexts which seek to inherit it, or utilize a static coding form that dynamically extends itself, like "ADD . /src", in which '.' immediately adapts to include all resources defined by the build context.  Neither choice represents a long-term solution.

The first method not only requires individuals using an image to adhere to a dictated build context, it additionally burdens those developing images to coordinate source path/file references, using either a centralize or distributed means, to avoid potential overlapping ones.  The second option, the one which dynamically extents the scope of an image's consumption, represents a vulnerability that can be maliciously or unintentionally exploited.  It also diminishes the reliability of processes executing within an <a href="#TermImageContext">*ImageContext*</a>, as additional unintended artifacts (resources) are copied into the destination specified by the command.  Review this [post](https://github.com/docker/docker/issues/7149#issuecomment-84171831) for a more detailed discussion regarding this vulnerability.

This proposal introduces a build context mapping mechanism that relates the static path/file references, encoded on Dockerfile commands required to execute a process(es), like a go compile, within an <a href="#TermImageContext">*ImageContext*</a>, to the rapidly growing set of Dockerfile build contexts generated by developers leveraging this process(es).  Essentially, the proposal provides a means to assemble a <a name="TermLocalBuildContext"></a>*LocalBuildContext*: a tailored version of the build context for a process(es) running within an <a href="#TermImageContext">*ImageContext*</a>.  As suggested by its intent, the mapping mechanism associates a build context reference, like a path or file, to a corresponding one encoded within a Dockerfile command.  To record these mappings, this proposal recommends extending the current FROM Dockerfile command with a new keyword called "CONTEXT". This purposeful association of "CONTEXT" to FROM stems from:
+ The current semantics of ONBUILD triggers, as they stipulate their execution to occur within the lexical encoding of FROM, currently preventing their override or injection of other Dockerfile commands ([#8240](https://github.com/docker/docker/issues/8240) would permit injection).  More importantly, CONTEXT's encoded mappings are generally unique to a given build context requiring frequent encoding of "CONTEXT".  If CONTEXT were encoded as an individual Dockerfile command, trigger injection would become the norm instead of the exception, undermining a trigger's encapsulation quality. 
+ Its analogous behavior, when containing ONBUILD triggers and/or a sequence of associated Dockerfile commands, like RUN, to ["docker run"](https://docs.docker.com/reference/run/) which in turn resembles a [function's](http://en.wikipedia.org/wiki/Subroutine) invocation.  In a sense, "CONTEXT" defines the parameter list being passed to the <a href="#TermImageContext">*ImageContext*</a> initiated by the FROM keyword.

The remainder of the proposal's presentation discusses CONTEXT's <a href="#Syntax">Syntax</a>, <a href="#Semantics">Semantics</a>, <a href="#Benefits">Benefits</a>, and provides an <a href="#Example">Example</a> to demonstrate its utility.

### Syntax <a name="Syntax"></a>
````
    FROM ... [CONTEXT {\<BuildContextReference\>:\<BuildContextForImageReference\>
                      [\<BuildContextReference\>:\<BuildContextForImageReference\>]... | NULL}]
````

#### Terms
+ [*FROM ...*](https://docs.docker.com/reference/builder/#from)
+ *\<BuildContextReference\>*<a name="TermsBuildContextReference">: Defines a path/file reference resolved within the build context provided by "docker build". The reference may contain wildcards conforming to the syntax and semantics of [Go's filepath.Match,](http://golang.org/pkg/path/filepath#Match)
+ *\<BuildContextForImageReference\>*<a name="TermsBuildContextForImageReference">: A path or file reference to appear in the <a href="#TermLocalBuildContext">*LocalBuildContext*</a> assembled for the <a href="#TermImageContext">*ImageContext*</a> initiated by FROM.  This assembled context conforms to the interface expected by or/and defines the interface exposed to an *ImageContext* when executing its Dockerfie commands.
+ *ContextMapEntry*: A paired specification of \<BuildContextReference\>:\<BuildContextForImageReference\>.  It defines two concepts:
 + *ContributingSet* : The set of artifacts (path/file) objects supplied by the build context.  Resolution of *\<BuildContextReference\>* determines the members of this set.
 + *ContributingSetLabel* : A name assigned to a *ContributingSet*.  This name appears in the *LocalBuildContext* as referencing the *ContributingSet*.  *ContributingSetLabel* is assigned the value of \<BuildContextForImageReference\>.
+ <a name="TermImageContext"></a>*ImageContext*: A process execution environment constructed by an initiating FROM and its associated Dockerfie commands.   A Dockerfile command associates/couples to the lexically nearest FROM statement that precedes it.

### Semantics <a name="Semantics"></a>

Conceptual method to assemble the <a href="#TermLocalBuildContext">*LocalBuildContext*</a>.
+ For each *ContextMapEntry*:
 + Resolve any environment variables specified in either \<BuildContextReference\> or \<BuildContextForImageReference\>.
 + Calculate the *ContributingSet* by resolving and applying \<BuildContextReference\> to the build context.
    + A file name uniquely identifies an element within the *ContributingSet*.
    + Recursively visit subdirectories, qualifying each file name with the path relative to the root files.  
 + For the resulting *ContributingSet* assign \<BuildContextForImageReference\>, as its *ContributingSetLabel*. The *ContributingSetLabel* itself becomes an element in the set called the <a href="#TermLocalBuildContext">*LocalBuildContext*</a>.  
 + Add or merge the element named *ContributingSetLabel* to the *LocalBuildContext*.
    + if the *LocalBuildContext* already contains an element with the same *ContributingSetLabel*, use set [Union](http://en.wikipedia.org/wiki/Union_%28set_theory%29) to merge both sets of *ContributingSet*.
        + In the situation where elements are identically named, perform an additional check to ensure, from a repeatability perspective, identical content and metadata.
          +  If completely identical, discard the duplicate.
          +  Otherwise, generate a build error describing an inability to ensure repeatability.
+ The NULL keyword produces an empty LocalBuildContext, prohibiting an <a href="#TermImageContext">*ImageContext*</a>'s Dockerfile commands from accessing resources located in the build context.
+ Re-assembly of the <a href="#TermLocalBuildContext">*LocalBuildContext*</a> occurs when the value of any environment variable specified in the references define by *ContextMapEntry* changes.
+ The current caching model, if it considers the file name metadata to include only a file's/directory's name, absent its path within the build context, will be oblivious to the mapping mechanism.
+ To remain compatible with existing Dockerfile code, the absence of the CONTEXT keyword permits an *ImageContext* to directly access the build context.

### Benefits <a name="Benefits"></a>
+ Encourages encapsulation from both the perspective of a Dockerfile and an <a href="#TermImageContext">*ImageContext*</a>.  A Dockerfile exposes only the resources in a build context it wishes an *ImageContext* to access, while an *ImageContext* can statically, independently define its required interface.  For example, a secret key can be delivered to exactly the required *ImageContext* without exposing it to any other *ImageContext* encoded within a multi FROM Dockerfile, greatly reducing the attack surface of the vulnerability mentioned above.
+ Promotes encoding of ONBUILD triggers, as these commands can bind to statically defined references that are then dynamically resolved when executed.  ONBUILD triggers encapsulate repetitive code, thus reducing/eliminating manually generated code.  This concision increases a Dockerfile's [declarative benefit](https://github.com/docker/docker/issues/8660#declarativebenefit).
+ Adapts the structure of directories/files that exist in other committed containers, exposed by [#12415](https://github.com/docker/docker/issues/12415), to conform to the source directories/file references specified by ADD/COPY.  The ADD/COPY command source references reflect an interface that's oblivious to their actual physical location. Therefore, when the physical location of a directory/file changes, mappings specified by CONTEXT change but the source directory/file references specified by ADD/COPY operators remain the same.
+ Enables the partitioning of an aggregated build context - a Dockerfile with more than one FROM statement.
+ Since CONTEXT declares the minimal dependencies required by a given FROM, these declared dependencies can be utilized to assist, along with information from [#12415](https://github.com/docker/docker/issues/12415), in determining the execution order and schedule of potentially concurrent build steps (multiple FROMs).

### Example <a name="Example"></a>

Create three different go applications within one Dockerfile using the [google/golang-runtime](https://registry.hub.docker.com/u/google/golang-runtime/dockerfile/) image.  It would be difficult to achieve the result below, with the given build context, without CONTEXT support, as golang-runtime relies on the following trigger "ONBUILD ADD . /gopath/src/app/".  

##### Build Context
```
    /
      Dockerfile
    /app1
      main.go
    /app2
      main.go
    /app3
      main.go
```
##### Dockerfile

    FROM google/golang-runtime CONTEXT /app1/main.go:/
    FROM google/golang-runtime CONTEXT /app2/*:/
    FROM google/golang-runtime CONTEXT /app3/:/

In each FROM above, the go source code is mapped to the root directory of the <a href="#TermLocalBuildContext">*LocalBuildContext*</a> seen by the trigger statements executing within the <a href="#TermImageContext">*ImageContext*</a> defined by google/golang-runtime.  Therefore, files like the Dockerfile, that would typically be silently consumed and appear in the image derived from google/golang-runtime are excluded.

Signed-off-by: Rich Moyse <rich@moyse.us>
