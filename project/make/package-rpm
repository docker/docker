#!/bin/bash

DEST=$1

PKGVERSION="${VERSION//-/'~'}"
# if we have a "-dev" suffix or have change in Git, let's make this package version more complex so it works better
if [[ "$VERSION" == *-dev ]] || [ -n "$(git status --porcelain)" ]; then
	GIT_UNIX="$(git log -1 --pretty='%at')"
	GIT_DATE="$(date --date "@$GIT_UNIX" +'%Y%m%d.%H%M%S')"
	GIT_COMMIT="$(git log -1 --pretty='%h')"
	GIT_VERSION="git${GIT_DATE}.0.${GIT_COMMIT}"
	# GIT_VERSION is now something like 'git20150128.112847.0.17e840a'
	PKGVERSION="$PKGVERSION~$GIT_VERSION"
fi

# probably shouldn't be using dpkg here...
PACKAGE_ARCHITECTURE="$(dpkg-architecture -qDEB_HOST_ARCH)"

# source the .packages file
source "$(dirname "$BASH_SOURCE")/.packages"

# Build docker as a rpm package using FPM and REPREPRO (sue me).
# bundle_binary must be called first.
bundle_rpm() {
	DIR=$DEST/build

	# include udev rules, contributed init, completions & man pages
	bundle_udev
	bundle_init
	bundle_completions
	bundle_manpages

	# Copy the binary
	# This will fail if the binary bundle hasn't been built
	mkdir -p $DIR/usr/bin
	cp $DEST/../binary/docker-$VERSION $DIR/usr/bin/docker

	# Generate postinst/prerm/postrm scripts
	cat > $DEST/postinst <<'EOF'
#!/bin/sh
set -e
set -u

if [ "$1" = 'configure' ] && [ -z "$2" ]; then
	if ! getent group docker > /dev/null; then
		groupadd --system docker
	fi
fi

if ! { [ -x /sbin/initctl ] && /sbin/initctl version 2>/dev/null | grep -q upstart; }; then
	# we only need to do this if upstart isn't in charge
	update-rc.d docker defaults > /dev/null || true
fi
if [ -n "$2" ]; then
	_dh_action=restart
else
	_dh_action=start
fi
service docker $_dh_action 2>/dev/null || true
EOF
	cat > $DEST/prerm <<'EOF'
#!/bin/sh
set -e
set -u

service docker stop 2>/dev/null || true
EOF
	cat > $DEST/postrm <<'EOF'
#!/bin/sh
set -e
set -u

if [ "$1" = "purge" ] ; then
	update-rc.d docker remove > /dev/null || true
fi

# In case this system is running systemd, we make systemd reload the unit files
# to pick up changes.
if [ -d /run/systemd/system ] ; then
	systemctl --system daemon-reload > /dev/null || true
fi
EOF
	# TODO swaths of these were borrowed from debhelper's auto-inserted stuff, because we're still using fpm - we need to use debhelper instead, and somehow reconcile Ubuntu that way
	chmod +x $DEST/postinst $DEST/prerm $DEST/postrm

	(
		# switch directories so we create *.rpm in the right folder
		cd $DEST

		# create lxc-docker-VERSION package
		fpm -s dir -C $DIR \
			--name lxc-docker-$VERSION --version "$PKGVERSION" \
			--after-install $DEST/postinst \
			--before-remove $DEST/prerm \
			--after-remove $DEST/postrm \
			--architecture "$PACKAGE_ARCHITECTURE" \
			--prefix / \
			--depends iptables \
			--description "$PACKAGE_DESCRIPTION" \
			--maintainer "$PACKAGE_MAINTAINER" \
			--conflicts docker \
			--conflicts docker-io \
			--conflicts lxc-docker-virtual-package \
			--provides lxc-docker \
			--provides lxc-docker-virtual-package \
			--replaces lxc-docker \
			--replaces lxc-docker-virtual-package \
			--url "$PACKAGE_URL" \
			--license "$PACKAGE_LICENSE" \
			--config-files /etc/udev/rules.d/80-docker.rules \
			--config-files /etc/init.d/docker \
			--config-files /etc/default/docker \
			--rpm-compression gzip \
			--epoch 0 \
			-t rpm .

		# create empty lxc-docker wrapper package
		fpm -s empty \
			--name lxc-docker --version "$PKGVERSION" \
			--architecture "$PACKAGE_ARCHITECTURE" \
			--depends lxc-docker-$VERSION \
			--description "$PACKAGE_DESCRIPTION" \
			--maintainer "$PACKAGE_MAINTAINER" \
			--url "$PACKAGE_URL" \
			--license "$PACKAGE_LICENSE" \
			--rpm-compression gzip \
			--epoch 0 \
			-t rpm
	)

	# clean up after ourselves so we have a clean output directory
	rm $DEST/postinst $DEST/prerm $DEST/postrm
	rm -r $DIR
}

bundle_rpm
